%% This Beamer template is based on the one found here: https://github.com/sanhacheong/stanford-beamer-presentation, and edited to be used for Stanford ARM Lab

\documentclass[10pt]{beamer}
%\mode<presentation>{}

\usepackage{media9}
\usepackage{amssymb,amsmath,amsthm,enumerate}
\usepackage{mathtools}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage[parfill]{parskip}
\usepackage[utf8]{vietnam}
\usepackage{graphicx,animate}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{bm}
\usepackage{amsfonts,amscd}
\usepackage[]{units}
\usepackage{listings}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{tcolorbox}
\usepackage{physics}
\usepackage{movie15}
% Enable colored hyperlinks
\hypersetup{colorlinks=true}

\usefonttheme{professionalfonts}

% The following three lines are for crossmarks & checkmarks
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

% Numbered captions of tables, pictures, etc.
\setbeamertemplate{caption}[numbered]
\usepackage{media9} 
%\usepackage[superscript,biblabel]{cite}
%\usepackage{algorithmic}
%\usepackage{algorithm2e}
%\usepackage{algpseudocode}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\usepackage{algorithm}
%\usepackage{algorithmic}
%\usepackage{caption}
\usepackage[font=scriptsize,justification=centering]{caption}
%\usepackage{xcolor}
\usepackage{array}
%\renewcommand{\thealgocf}{}

\usepackage[natbib,backend=biber,style=ieee, sorting=ynt]{biblatex}
\bibliography{ref.bib}

\usepackage[acronym]{glossaries}

\usepackage{graphicx}
\graphicspath{{./figures}}
\usepackage{hyperref}

\setbeamertemplate{theorems}[numbered]
\theoremstyle{remark}
\newtheorem{dl}{Định lý}
\newtheorem{md}{Mệnh đề}
\newtheorem{bd}{Bổ đề}
\newtheorem{dn}{Định nghĩa}
\newtheorem{hq}{Hệ quả}
%\theoremstyle{definition}

\numberwithin{algocf}{section}
\numberwithin{equation}{section}
\numberwithin{dl}{section}
\numberwithin{figure}{section}


%\newcommand{\empy}[1]{{\color{darkorange}\emph{#1}}}
%\newcommand{\empr}[1]{{\color{cardinalred}\emph{#1}}}
%\newcommand{\examplebox}[2]{
%\begin{tcolorbox}[colframe=darkcardinal,colback=boxgray,title=#1]
%#2
%\end{tcolorbox}}

%\usetheme{Stanford} 
%\input{./style_files_stanford/my_beamer_defs.sty}
\usetheme{Copenhagen}
\usecolortheme{seahorse}
%\logo{\includegraphics[height=0.5in]{logos/HUS-name.jpg}}

\makeatletter
\let\@@magyar@captionfix\relax
\makeatother

\title[Phương pháp tiếp cận lý thuyết đồ thị giải trình tự DNA]{Phương pháp tiếp cận \\ lý thuyết đồ thị giải trình tự DNA}

\AtBeginSection[]
{
    \begin{frame}
        \frametitle{Nội dung}
        \tableofcontents[currentsection, subsectionstyle=show/show/hide]
    \end{frame}
}

\setbeamertemplate{page number in head/foot}[totalframenumber]
\setbeamertemplate{frametitle continuation}{}

\begin{document}
\author[Nguyễn Chí Thanh - Vũ Ngọc Đại - Vũ Minh Hưng - Lê Diệu Thúy]{
	\begin{tabular}{c c}  
    Nguyễn Chí Thanh & Vũ Ngọc Đại \\
    \footnotesize \href{mailto:nguyenchithanh\_sdh21@hus.edu.vn}{nguyenchithanh\_sdh21@hus.edu.vn} & \footnotesize \href{mailto:vungocdai\_sdh21@hus.edu.vn}{vungocdai\_sdh21@hus.edu.vn} \\
    Vũ Minh Hưng & Lê Diệu Thúy \\
    \footnotesize \href{mailto:nguyenchithanh\_sdh21@hus.edu.vn}{nguyenchithanh\_sdh21@hus.edu.vn} & \footnotesize \href{mailto:nguyenchithanh\_sdh21@hus.edu.vn}{nguyenchithanh\_sdh21@hus.edu.vn}
\end{tabular}
\vspace{-4ex}}

\institute{
	\vskip 5pt
	\begin{figure}
		\centering
		\begin{subfigure}[t]{0.5\textwidth}
			\centering
			\includegraphics[height=0.75in]{logos/HUS-logo.jpg}
		\end{subfigure}%
		~ 
		\begin{subfigure}[t]{0.5\textwidth}
			\centering
			\includegraphics[height=0.75in]{logos/MIM-logo.png}
		\end{subfigure}
	\end{figure}
	\vskip 5pt	
	Đại học Quốc Gia Hà Nội \\
	Trường đại học Khoa học tự nhiên\\
	Khoa Toán - Cơ - Tin học
	\vskip 3pt
}

%\begin{noheadline}
\begin{frame} \maketitle \end{frame}
%\end{noheadline}
    
\setbeamertemplate{itemize items}[default]
\setbeamertemplate{itemize subitem}[circle]

\begin{frame}{Nội dung}
    \tableofcontents[hidesubsections]
\end{frame}

\section{Thực nghiệm}

\begin{frame}{Thuật toán xác định các đoạn chồng lấn}
    \begin{algorithm}[H]
        \DontPrintSemicolon
        \KwIn{Chuỗi str\_1: \KwSty{str} và str\_2: \KwSty{str}, đoạn ngắn nhất trùng để hai đoạn được xem là có chồng min\_length: \KwSty{int}}
        pos: \KwSty{int} $\gets$ -1\;
        \For{i $\gets$ min\_length \KwTo $\min$(str\_1.length, str\_2.length)}{
            suff $\gets$ str\_1 [-i:]\;
            pref $\gets$ str\_2 [:i]\;
            \If{suff = pref}{
                pos $\gets$ i\;
            }
        }
        \Return{pos}\;
        \caption{OVERLAP}
    \end{algorithm}
\end{frame}


\begin{frame}{Thuật toán xác định các đoạn chồng lấn}
    \begingroup
        \scalebox{0.75}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{Tập các read read\_list: \KwSty{List[Read]}, min\_length: \KwSty{int}}
                    \While{read\_list.length > 0}{
                        first $\gets$ read\_list.pop(0)\;
                        the\_rest $\gets$ read\_list.copy()\;
                        \ForEach{second $\in$ the\_rest}{
                            first\_pos $\gets$ OVERLAP(first.sequence, second.sequence, min\_length)\;
                            second\_pos $\gets$ OVERLAP(second.sequence, first.sequence, min\_length)\;
            
                            \If{first\_pos $\neq$ -1}{
                                first.front\_of [second] $\gets$ (first.length - first\_pos, first\_pos)\;
                                second.behind\_of [first] $\gets$ (first.length - first\_pos, first\_pos)\;
                            }
            
                            \If{second\_pos $\neq$ -1}{
                                second.front\_of [first] $\gets$ (second.length - second\_pos, second\_pos)\;
                                first.behind\_of [second] $\gets$ (second.length - second\_pos, second\_pos)\;
                            }
                        }
                    }
                    \caption{ALIGN\_READ}
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{Thuật toán xác định bội cạnh}
    \begingroup
        \scalebox{0.65}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read, edge, i$ là vị trí của ký tự đầu tiên của $edge$ trong $read$}
                    $exist \gets false$\;
                    $overlap\_reads \gets read.front\_of$\;
                    \ForEach{$over\_read \in overlap\_reads$}{
                        $pos:$\KwSty{Tuple \lbrack int, int \rbrack} $\gets overlap\_reads \lbrack over\_read \rbrack$\;
                        \If{$i \geq pos \lbrack 0 \rbrack $}{
                            \If{$over\_read \in edge.position\_in\_read$}{
                                $position\_in\_overlap\_read \gets edge.position\_in\_read \lbrack over\_read \rbrack$\;
                                \ForEach{$position \in position\_in\_overlap\_read$}{
                                    \If{$position + edge.sequence.length \leq pos \lbrack 1 \rbrack$}{
                                        $exist \gets true$\;
                                    }
                                }
                            }
                        }
                    }
                    $overlap\_reads \gets read.behind\_of$\;
                    \ForEach{$over\_read \in overlap\_reads$}{
                        $pos:$\KwSty{Tuple \lbrack int, int \rbrack} $\gets overlap\_reads \lbrack over\_read \rbrack$\;
                        \If{$i + edge.sequence.length \leq pos \lbrack 1 \rbrack $}{
                            \If{$over\_read \in edge.position\_in\_read$}{
                                $position\_in\_overlap\_read \gets edge.position\_in\_read \lbrack over\_read \rbrack$\;
                                \ForEach{$position \in position\_in\_overlap\_read$}{
                                    \If{$position \geq pos \lbrack 0 \rbrack$}{
                                        $exist \gets true$\;
                                    }
                                }
                            }
                        }
                    }
                \If{$!exist$} {
                    $edge.multiplicities \gets edge.multiplicities + 1$\;
                }
                \caption{DETERMINE\_EDGE\_MULTIPLICITIES}
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{Thuật toán kiểm tra hai cạnh có phải là liền kề trong một Read hay không}
    \begingroup
        \scalebox{0.8}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read:$ \KwSty{Read}$, x:$ \KwSty{Edge} $, y:$ \KwSty{Edge}}
                    $found\_xy:$ \KwSty{bool} $\gets true$\;
                    $pos\_of\_edges:$ \KwSty{List \lbrack int \rbrack} $\gets list(read.position\_to\_edge.keys())$\;
                    \For{$i \gets 0$ \KwTo $pos\_of\_edges.length - 1$}{
                        \If{$read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i \rbrack \rbrack = x \cap read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i+1 \rbrack \rbrack = y$}{
                            $found\_xy \gets true$\;
                        }
                    }
                    \Return{$found\_xy$}
                    \caption{CHECK\_CONSECUTIVE\_EDGES}
                \end{algorithm}
            \end{minipage}
        }
    \endgroup  
\end{frame}

\begin{frame}{Thuật toán cập nhật vị trí các cạnh trong một Read khi x và y là liền kề}
    \begingroup
        \scalebox{0.4}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read:$ \KwSty{Read}$, x:$ \KwSty{Edge} $, y:$ \KwSty{Edge} $, z:$ \KwSty{Edge}}
                    $found\_xy:$ \KwSty{bool} $\gets true$\;
                    $pos\_of\_edges:$ \KwSty{List \lbrack int \rbrack} $\gets list(read.position\_to\_edge.keys())$\;
                    \For{$i \gets 0$ \KwTo $pos\_of\_edges.length - 1$}{
                        \If{$read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i \rbrack \rbrack = x \cap read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i+1 \rbrack \rbrack = y$}{
                            $found\_xy \gets true$\;
                            $read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i \rbrack \rbrack \gets z$\;
                            $read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i+1 \rbrack \gets null$\;
                            \For{$j \gets 0$ \KwTo $read.edges.length$}{
                                \If{$read.edges \lbrack j \rbrack = x$}{
                                    $read.edges \lbrack j \rbrack \gets z$\;
                                }
                                \If{$read.edges \lbrack j \rbrack = y$}{
                                    $read.edges \lbrack j \rbrack \gets null$\;
                                }
                            }
                            $z.reads.add(read)$\;
                            $read.add\_edge\_position(x=x, z=z, position=pos\_of\_edges \lbrack i \rbrack)$\;
                            $read.add\_edge\_position(x=y, z=z, position=pos\_of\_edges \lbrack i+1 \rbrack, replace_pos=False)$\;

                            \If{$read.edge\_to\_positions \lbrack x \rbrack.length = 0$}{
                                \KwSty{del} $read.edge\_to\_positions \lbrack x \rbrack$\;
                                \If{$read \in x.reads$}{
                                    $x.reads.remove(read)$\;
                                }
                            }
                            \If{$read.edge\_to\_positions \lbrack y \rbrack.length = 0$}{
                                \KwSty{del} $read.edge\_to\_positions \lbrack y \rbrack$\;
                                \If{$read \in y.reads$}{
                                    $y.reads.remove(read)$\;
                                }
                            }
                        }
                    }
                    $edge\_list \gets \emptyset$\;
                    \ForEach{$e \in read.edges$}{
                        \If{$e neq null$} {
                            $edge\_list.add(e)$\;
                        }
                    }
                    $read.edges \gets edge\_list$\;
                    \ForEach{$pos \in pos\_of\_edges$}{
                        \If{$read.position\_to\_edge \lbrack pos \rbrack = null$} {
                            \KwSty{del} $read.position\_to\_edge \lbrack pos \rbrack$\;
                        }
                    }
                    \Return{$found\_xy$}\;
                    \caption{CHANGE\_XY}
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{Thuật toán xác định chênh lệch bậc ra và bậc vào của một đỉnh}
    \begin{algorithm}[H]
        \DontPrintSemicolon
        \KwIn{$vertex:$ \KwSty{Vertex}}
        $in\_dgree:$ \KwSty{int} $\gets 0$\;
        \ForEach{$in\_edge \in vertex.in\_edges$}{
            $in\_degree \gets in\_degree + in\_edge.multiplicities$\;
        }
        $out\_dgree:$ \KwSty{int} $\gets 0$\;
        \ForEach{$out\_edge \in vertex.out\_edges$}{
            $out\_degree \gets out\_degree + out\_edge.multiplicities$\;
        }
        \Return{$out\_degree - in\_degree$}\;
        \caption{COMPUTE\_DEGREE}
    \end{algorithm}
\end{frame}

\begin{frame}{Thuật toán cập nhật vị trí các cạnh trong một Read khi x là cạnh kết thúc Read}
    \begingroup
        \scalebox{0.8}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read:$ \KwSty{Read}$, x:$ \KwSty{Edge} $, z:$ \KwSty{Edge}}
                    $pos\_of\_edges:$ \KwSty{List \lbrack int \rbrack} $\gets list(read.position\_to\_edge.keys())$\;
                    \If{$read.position\_to\_edge \lbrack pos\_of\_edges \lbrack -1 \rbrack \rbrack = x$}{
                        $read.position\_to\_edge \lbrack pos\_of\_edges \lbrack -1 \rbrack \rbrack \gets z$\;

                        \For{$i \gets 0$ \KwTo $read.edges.length - 1$}{
                            \If{$read.edges \lbrack i \rbrack = x$}{
                                $read.edges \lbrack i \rbrack \gets z$\;
                            }
                        }

                        $z.reads.add(read)$\;

                        $read.add\_edge\_position(x=x, z=x, position=pos\_of\_edges \lbrack -1 \rbrack)$\;

                        \If{$read.edge\_to\_positions \lbrack x \rbrack.length = 0$} {
                            \KwSty{del} $read.edge\_to\_positions \lbrack x \rbrack$\;
                            \If{$read \in x.reads$} {
                                $x.reads.remove(read)$\;
                            }
                        }
                        \Return{$true$}\;
                    }
                    \Return{$false$}\;
                    \caption{CHANGE\_X}\;
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{Thuật toán cập nhật vị trí các cạnh trong một Read khi y là cạnh bắt đầu Read}
    \begingroup
        \scalebox{0.8}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read:$ \KwSty{Read}$, x:$ \KwSty{Edge} $, z:$ \KwSty{Edge}}
                    $pos\_of\_edges:$ \KwSty{List \lbrack int \rbrack} $\gets list(read.position\_to\_edge.keys())$\;
                    \If{$read.position\_to\_edge \lbrack pos\_of\_edges \lbrack 0 \rbrack \rbrack = y$}{
                        $read.position\_to\_edge \lbrack pos\_of\_edges \lbrack 0 \rbrack \rbrack \gets z$\;

                        \For{$i \gets 0$ \KwTo $read.edges.length - 1$}{
                            \If{$read.edges \lbrack i \rbrack = y$}{
                                $read.edges \lbrack i \rbrack \gets z$\;
                            }
                        }

                        $z.reads.add(read)$\;

                        $read.add\_edge\_position(x=y, z=x, position=pos\_of\_edges \lbrack 0 \rbrack)$\;

                        \If{$read.edge\_to\_positions \lbrack y \rbrack.length = 0$} {
                            \KwSty{del} $read.edge\_to\_positions \lbrack y \rbrack$\;
                            \If{$read \in y.reads$} {
                                $y.reads.remove(read)$\;
                            }
                        }
                        \Return{$true$}\;
                    }
                    \Return{$false$}\;
                    \caption{CHANGE\_Y}\;
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{Thuật toán kiểm tra đồ thị Euler}
    \begin{algorithm}[H]
        \DontPrintSemicolon
        \KwIn{$vertex\_list:$ \KwSty{List \lbrack Vertex \rbrack}}
        $diff\_list:$ \KwSty{List \lbrack int \rbrack} $\gets \emptyset$\;
        \ForEach{$vertex \in vertex\_list$}{
            $diff\_mul \gets vertex.compute_degree()$\;
            \If{$diff\_mul = 0$} {
                $continue$\;
            } \Else {
                \If{$\lvert diff\_mul \rvert \geq 2$} {
                    \Return{$false$}\;
                }
                \Else {
                    $diff\_list.add(diff\_mul)$\;
                }
            }
        }
        \If{$diff\_list.length = 2 \cap diff\_list \lbrack 0 \rbrack \times diff\_list \lbrack 1 \rbrack =-1 $} {
            \Return{$true$}\;
        } \Else{
            \Return{$false$}\;
        }
    \end{algorithm}
\end{frame}

\begin{frame}{Thuật toán tìm đường đi Euler}
    \begingroup
        \scalebox{0.8}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$path:$ \KwSty{List \lbrack Edge \rbrack}, $vertex:$ \KwSty{Vertex}, $end\_vertex:$ \KwSty{Vertex}}
            
                    $out\_edges:$ \KwSty{List \lbrack Edge \rbrack} $\gets vertex.out\_edges$\;
                    \ForEach{$o\_edge \in out\_edges$}{
                        \If{$o\_edge.visited < o\_edge.multiplicities$}{
                            $o\_edge.multiplicities = o\_edge.multiplicities + 1$\;
                            $path.add(o\_edge)$\;
                            $all\_visited:$ \KwSty{bool} $\gets graph.check\_all\_visited()$\;
                            $o\_vertex:$ \KwSty{Vertex} $\gets o\_vertex.out\_vertex$\;
                            \If{$all\_visited \cap o\_vertex = end\_vertex$} {
                                \Return {$path, all\_visited, o\_vertex = end\_vertex$}\;
                            } \Else{
                                \If{$o\_vertex \neq end\_vertex$} {
                                    $path, all\_visited, end\_equal = DFS\_VISIT(path=path, vertex=o\_vertex, end\_vertex=end\_vertex)$\;
                                    \If{$all\_visited \cap end\_equal$}{
                                        \Return{$path, all\_visited, end\_equal$}\;
                                    }
                                } \Else{
                                    $path.remove(o\_edge)$\;
                                    $o\_edge.visited = o\_edge.visited - 1$\;
                                }
                            }
                        }
                    }
                    \caption{DFS\_VISIT}
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{{Thuật toán tìm đường đi Euler}}
    
    \begingroup
        \scalebox{0.8}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{vertex\_list: \KwSty{List \lbrack Vertex \rbrack}, k: \KwSty{int}}
                    start\_vertex $\gets$ null\;
                    end\_vertex $\gets$ null\;
                    \ForEach{vertex $\in$ vertex\_list}{
                        \If{vertex.compute\_degree() = 1}{
                            start\_vertex $\gets$ vertex\;
                        }
                        \If{vertex.compute\_degree() = -1}{
                            end\_vertex $\gets$ vertex\;
                        }
                    }
                    path: \KwSty{List \lbrack Edge \rbrack} $\gets \emptyset$\;
                    path, all\_visited, end\_equal $\gets$ DFS\_VISIT(path=path, vertex=start\_vertex, end\_vertex=end\_vertex)\;
                    origin\_string: \KwSty{str} $\gets$ ""\;
                    \For{i $\gets$ 0 \KwTo path.length}{
                        \If{i = 0} {
                            origin\_string $\gets$ path[i].sequence\;
                        } \Else{
                            origin\_string $\gets$ origin\_string + path[i].sequence[k-1:]
                        }
                    }
                    \Return{origin\_string}\;
                    \caption{FIND\_EULERIAN\_PATH}\;
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}
\end{document}