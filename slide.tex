%% This Beamer template is based on the one found here: https://github.com/sanhacheong/stanford-beamer-presentation, and edited to be used for Stanford ARM Lab

\documentclass[10pt]{beamer}
%\mode<presentation>{}

\usepackage{media9}
\usepackage{amssymb,amsmath,amsthm,enumerate}
\usepackage{mathtools}
\usepackage[utf8]{inputenc}
\usepackage{array}
\usepackage[parfill]{parskip}
\usepackage[utf8]{vietnam}
\usepackage{graphicx,animate}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{bm}
\usepackage{amsfonts,amscd}
\usepackage[]{units}
\usepackage{listings}
\usepackage{multicol}
\usepackage{multirow}
\usepackage{tcolorbox}
\usepackage{physics}
\usepackage{movie15}
% Enable colored hyperlinks
\hypersetup{colorlinks=true}

\usefonttheme{professionalfonts}

% The following three lines are for crossmarks & checkmarks
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

% Numbered captions of tables, pictures, etc.
\setbeamertemplate{caption}[numbered]
\usepackage{media9} 
%\usepackage[superscript,biblabel]{cite}
%\usepackage{algorithmic}
%\usepackage{algorithm2e}
%\usepackage{algpseudocode}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
%\usepackage{algorithm}
%\usepackage{algorithmic}
%\usepackage{caption}
\usepackage[font=scriptsize,justification=centering]{caption}
%\usepackage{xcolor}
\usepackage{array}
%\renewcommand{\thealgocf}{}

\usepackage[natbib,backend=biber,style=ieee, sorting=ynt]{biblatex}
\bibliography{ref.bib}

\usepackage[acronym]{glossaries}

\usepackage{graphicx}
\graphicspath{{./figures}}
\usepackage{hyperref}

\setbeamertemplate{theorems}[numbered]
\theoremstyle{remark}
\newtheorem{dl}{Định lý}
\newtheorem{md}{Mệnh đề}
\newtheorem{bd}{Bổ đề}
\newtheorem{dn}{Định nghĩa}
\newtheorem{hq}{Hệ quả}
%\theoremstyle{definition}

\numberwithin{algocf}{section}
\numberwithin{equation}{section}
\numberwithin{dl}{section}
\numberwithin{figure}{section}


%\newcommand{\empy}[1]{{\color{darkorange}\emph{#1}}}
%\newcommand{\empr}[1]{{\color{cardinalred}\emph{#1}}}
%\newcommand{\examplebox}[2]{
%\begin{tcolorbox}[colframe=darkcardinal,colback=boxgray,title=#1]
%#2
%\end{tcolorbox}}

%\usetheme{Stanford} 
%\input{./style_files_stanford/my_beamer_defs.sty}
\usetheme{Copenhagen}
\usecolortheme{seahorse}
%\logo{\includegraphics[height=0.5in]{logos/HUS-name.jpg}}

\makeatletter
\let\@@magyar@captionfix\relax
\makeatother

\title[Phương pháp tiếp cận lý thuyết đồ thị giải trình tự DNA]{Phương pháp tiếp cận \\ lý thuyết đồ thị giải trình tự DNA}

\AtBeginSection[]
{
    \begin{frame}
        \frametitle{Nội dung}
        \tableofcontents[currentsection, subsectionstyle=show/show/hide]
    \end{frame}
}

\setbeamertemplate{page number in head/foot}[totalframenumber]
\setbeamertemplate{frametitle continuation}{}

\begin{document}
\author[Nguyễn Chí Thanh - Vũ Ngọc Đại - Vũ Minh Hưng - Lê Diệu Thúy]{
	\begin{tabular}{c c}  
    Nguyễn Chí Thanh & Vũ Ngọc Đại \\
    \footnotesize \href{mailto:nguyenchithanh\_sdh21@hus.edu.vn}{nguyenchithanh\_sdh21@hus.edu.vn} & \footnotesize \href{mailto:vungocdai\_sdh21@hus.edu.vn}{vungocdai\_sdh21@hus.edu.vn} \\
    Vũ Minh Hưng & Lê Diệu Thúy \\
    \footnotesize \href{mailto:nguyenchithanh\_sdh21@hus.edu.vn}{nguyenchithanh\_sdh21@hus.edu.vn} & \footnotesize \href{mailto:nguyenchithanh\_sdh21@hus.edu.vn}{nguyenchithanh\_sdh21@hus.edu.vn}
\end{tabular}
\vspace{-4ex}}

\institute{
	\vskip 5pt
	\begin{figure}
		\centering
		\begin{subfigure}[t]{0.5\textwidth}
			\centering
			\includegraphics[height=0.75in]{logos/HUS-logo.jpg}
		\end{subfigure}%
		~ 
		\begin{subfigure}[t]{0.5\textwidth}
			\centering
			\includegraphics[height=0.75in]{logos/MIM-logo.png}
		\end{subfigure}
	\end{figure}
	\vskip 5pt	
	Đại học Quốc Gia Hà Nội \\
	Trường đại học Khoa học tự nhiên\\
	Khoa Toán - Cơ - Tin học
	\vskip 3pt
}

%\begin{noheadline}
\begin{frame} \maketitle \end{frame}
%\end{noheadline}
    
\setbeamertemplate{itemize items}[default]
\setbeamertemplate{itemize subitem}[circle]

\begin{frame}{Nội dung}
    \tableofcontents[hidesubsections]
\end{frame}

\section{Thực nghiệm}

\begin{frame}{Thuật toán xác định các đoạn chồng lấn}
    \begin{algorithm}[H]
        \DontPrintSemicolon
        \KwIn{Chuỗi $str\_1$ và $str\_2$, đoạn ngắn nhất trùng để hai đoạn được xem là có chồng $min\_length$}
        $pos \gets -1$\;
        \For{$i \gets min\_length$ \KwTo $\min(str\_1.length, str\_2.length)$}{
            $suff \gets str\_1 \lbrack -i: \rbrack$\;
            $pref \gets str\_2 \lbrack :i \rbrack$\;
            \If{$suff = pref$}{
                $pos \gets i$\;
            }
        }
        \Return{$pos$}\;
        \caption{OVERLAP}
    \end{algorithm}
\end{frame}


\begin{frame}{Thuật toán xác định các đoạn chồng lấn}
    \begingroup
        \scalebox{0.75}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{Tập các read $read\_list$, $min\_length$}
                    \While{$read\_list.length > 0$}{
                        $first \gets read\_list.pop(0)$\;
                        $the\_rest \gets read\_list.copy()$\;
                        \ForEach{$second \in the\_rest$}{
                            $first\_pos \gets OVERLAP(first.sequence, second.sequence, min\_length)$\;
                            $second\_pos \gets OVERLAP(second.sequence, first.sequence, min\_length)$\;
            
                            \If{$first\_pos \neq -1$}{
                                $first.front\_of \lbrack second \rbrack \gets (first.length - first\_pos, first\_pos)$\;
                                $second.behind\_of \lbrack first \rbrack \gets (first.length - first\_pos, first\_pos)$\;
                            }
            
                            \If{$second\_pos \neq -1$}{
                                $second.front\_of \lbrack first \rbrack \gets (second.length - second\_pos, second\_pos)$\;
                                $first.behind\_of \lbrack second \rbrack \gets (second.length - second\_pos, second\_pos)$\;
                            }
                        }
                    }
                    \caption{ALIGN\_READ}
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{Thuật toán xác định bội cạnh}
    \begingroup
        \scalebox{0.65}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read, edge, i$ là vị trí của ký tự đầu tiên của $edge$ trong $read$}
                    $exist \gets false$\;
                    $overlap\_reads \gets read.front\_of$\;
                    \ForEach{$over\_read \in overlap\_reads$}{
                        $pos:$\KwSty{Tuple \lbrack int, int \rbrack} $\gets overlap\_reads \lbrack over\_read \rbrack$\;
                        \If{$i \geq pos \lbrack 0 \rbrack $}{
                            \If{$over\_read \in edge.position\_in\_read$}{
                                $position\_in\_overlap\_read \gets edge.position\_in\_read \lbrack over\_read \rbrack$\;
                                \ForEach{$position \in position\_in\_overlap\_read$}{
                                    \If{$position + edge.sequence.length \leq pos \lbrack 1 \rbrack$}{
                                        $exist \gets true$\;
                                    }
                                }
                            }
                        }
                    }
                    $overlap\_reads \gets read.behind\_of$\;
                    \ForEach{$over\_read \in overlap\_reads$}{
                        $pos:$\KwSty{Tuple \lbrack int, int \rbrack} $\gets overlap\_reads \lbrack over\_read \rbrack$\;
                        \If{$i + edge.sequence.length \leq pos \lbrack 1 \rbrack $}{
                            \If{$over\_read \in edge.position\_in\_read$}{
                                $position\_in\_overlap\_read \gets edge.position\_in\_read \lbrack over\_read \rbrack$\;
                                \ForEach{$position \in position\_in\_overlap\_read$}{
                                    \If{$position \geq pos \lbrack 0 \rbrack$}{
                                        $exist \gets true$\;
                                    }
                                }
                            }
                        }
                    }
                \If{$!exist$} {
                    $edge.multiplicities \gets edge.multiplicities + 1$\;
                }
                \caption{DETERMINE\_EDGE\_MULTIPLICITIES}
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{Thuật toán kiểm tra hai cạnh có phải là liền kề trong một Read hay không}
    \begingroup
        \scalebox{0.8}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read:$ \KwSty{Read}$, x:$ \KwSty{Edge} $, y:$ \KwSty{Edge}}
                    $found\_xy:$ \KwSty{bool} $\gets true$\;
                    $pos\_of\_edges:$ \KwSty{List \lbrack int \rbrack} $\gets list(read.position\_to\_edge.keys())$\;
                    \For{$i \gets 0$ \KwTo $pos\_of\_edges.length - 1$}{
                        \If{$read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i \rbrack \rbrack = x \cap read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i+1 \rbrack \rbrack = y$}{
                            $found\_xy \gets true$\;
                        }
                    }
                    \Return{$found\_xy$}
                    \caption{CHECK\_CONSECUTIVE\_EDGES}
                \end{algorithm}
            \end{minipage}
        }
    \endgroup  
\end{frame}

\begin{frame}{Thuật toán cập nhật vị trí các cạnh trong một Read khi x và y là liền kề}
    \begingroup
        \scalebox{0.4}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read:$ \KwSty{Read}$, x:$ \KwSty{Edge} $, y:$ \KwSty{Edge} $, z:$ \KwSty{Edge}}
                    $found\_xy:$ \KwSty{bool} $\gets true$\;
                    $pos\_of\_edges:$ \KwSty{List \lbrack int \rbrack} $\gets list(read.position\_to\_edge.keys())$\;
                    \For{$i \gets 0$ \KwTo $pos\_of\_edges.length - 1$}{
                        \If{$read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i \rbrack \rbrack = x \cap read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i+1 \rbrack \rbrack = y$}{
                            $found\_xy \gets true$\;
                            $read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i \rbrack \rbrack \gets z$\;
                            $read.position\_to\_edge \lbrack pos\_of\_edges \lbrack i+1 \rbrack \gets null$\;
                            \For{$j \gets 0$ \KwTo $read.edges.length$}{
                                \If{$read.edges \lbrack j \rbrack = x$}{
                                    $read.edges \lbrack j \rbrack \gets z$\;
                                }
                                \If{$read.edges \lbrack j \rbrack = y$}{
                                    $read.edges \lbrack j \rbrack \gets null$\;
                                }
                            }
                            $z.reads.add(read)$\;
                            $read.add\_edge\_position(x=x, z=z, position=pos\_of\_edges \lbrack i \rbrack)$\;
                            $read.add\_edge\_position(x=y, z=z, position=pos\_of\_edges \lbrack i+1 \rbrack, replace_pos=False)$\;

                            \If{$read.edge\_to\_positions \lbrack x \rbrack.length = 0$}{
                                \KwSty{del} $read.edge\_to\_positions \lbrack x \rbrack$\;
                                \If{$read \in x.reads$}{
                                    $x.reads.remove(read)$\;
                                }
                            }
                            \If{$read.edge\_to\_positions \lbrack y \rbrack.length = 0$}{
                                \KwSty{del} $read.edge\_to\_positions \lbrack y \rbrack$\;
                                \If{$read \in y.reads$}{
                                    $y.reads.remove(read)$\;
                                }
                            }
                        }
                    }
                    $edge\_list \gets \emptyset$\;
                    \ForEach{$e \in read.edges$}{
                        \If{$e neq null$} {
                            $edge\_list.add(e)$\;
                        }
                    }
                    $read.edges \gets edge\_list$\;
                    \ForEach{$pos \in pos\_of\_edges$}{
                        \If{$read.position\_to\_edge \lbrack pos \rbrack = null$} {
                            \KwSty{del} $read.position\_to\_edge \lbrack pos \rbrack$\;
                        }
                    }
                    \Return{$found\_xy$}\;
                    \caption{CHANGE\_XY}
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{Thuật toán xác định chênh lệch bậc ra và bậc vào của một đỉnh}
    \begin{algorithm}[H]
        \DontPrintSemicolon
        \KwIn{$vertex:$ \KwSty{Vertex}}
        $in\_dgree:$ \KwSty{int} $\gets 0$\;
        \ForEach{$in\_edge \in vertex.in\_edges$}{
            $in\_degree \gets in\_degree + in\_edge.multiplicities$\;
        }
        $out\_dgree:$ \KwSty{int} $\gets 0$\;
        \ForEach{$out\_edge \in vertex.out\_edges$}{
            $out\_degree \gets out\_degree + out\_edge.multiplicities$\;
        }
        \Return{$out\_degree - in\_degree$}\;
        \caption{COMPUTE\_DEGREE}
    \end{algorithm}
\end{frame}

\begin{frame}{Thuật toán cập nhật vị trí các cạnh trong một Read khi x là cạnh kết thúc Read}
    \begingroup
        \scalebox{0.8}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read:$ \KwSty{Read}$, x:$ \KwSty{Edge} $, z:$ \KwSty{Edge}}
                    $pos\_of\_edges:$ \KwSty{List \lbrack int \rbrack} $\gets list(read.position\_to\_edge.keys())$\;
                    \If{$read.position\_to\_edge \lbrack pos\_of\_edges \lbrack -1 \rbrack \rbrack = x$}{
                        $read.position\_to\_edge \lbrack pos\_of\_edges \lbrack -1 \rbrack \rbrack \gets z$\;

                        \For{$i \gets 0$ \KwTo $read.edges.length - 1$}{
                            \If{$read.edges \lbrack i \rbrack = x$}{
                                $read.edges \lbrack i \rbrack \gets z$\;
                            }
                        }

                        $z.reads.add(read)$\;

                        $read.add\_edge\_position(x=x, z=x, position=pos\_of\_edges \lbrack -1 \rbrack)$\;

                        \If{$read.edge\_to\_positions \lbrack x \rbrack.length = 0$} {
                            \KwSty{del} $read.edge\_to\_positions \lbrack x \rbrack$\;
                            \If{$read \in x.reads$} {
                                $x.reads.remove(read)$\;
                            }
                        }
                        \Return{$true$}\;
                    }
                    \Return{$false$}\;
                    \caption{CHANGE\_X}\;
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}

\begin{frame}{Thuật toán cập nhật vị trí các cạnh trong một Read khi y là cạnh bắt đầu Read}
    \begingroup
        \scalebox{0.8}{
            \begin{minipage}{1.2\linewidth}
                \begin{algorithm}[H]
                    \DontPrintSemicolon
                    \KwIn{$read:$ \KwSty{Read}$, x:$ \KwSty{Edge} $, z:$ \KwSty{Edge}}
                    $pos\_of\_edges:$ \KwSty{List \lbrack int \rbrack} $\gets list(read.position\_to\_edge.keys())$\;
                    \If{$read.position\_to\_edge \lbrack pos\_of\_edges \lbrack 0 \rbrack \rbrack = y$}{
                        $read.position\_to\_edge \lbrack pos\_of\_edges \lbrack 0 \rbrack \rbrack \gets z$\;

                        \For{$i \gets 0$ \KwTo $read.edges.length - 1$}{
                            \If{$read.edges \lbrack i \rbrack = y$}{
                                $read.edges \lbrack i \rbrack \gets z$\;
                            }
                        }

                        $z.reads.add(read)$\;

                        $read.add\_edge\_position(x=y, z=x, position=pos\_of\_edges \lbrack 0 \rbrack)$\;

                        \If{$read.edge\_to\_positions \lbrack y \rbrack.length = 0$} {
                            \KwSty{del} $read.edge\_to\_positions \lbrack y \rbrack$\;
                            \If{$read \in y.reads$} {
                                $y.reads.remove(read)$\;
                            }
                        }
                        \Return{$true$}\;
                    }
                    \Return{$false$}\;
                    \caption{CHANGE\_Y}\;
                \end{algorithm}
            \end{minipage}
        }
    \endgroup
\end{frame}
\end{document}